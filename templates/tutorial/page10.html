<p>
  Success! Now you can call this new <code>square</code> function just like you called the old <code>square</code> function.
</p>

<p>
  By now, you know that lists are quite important in Racket.
  But Racket also has other data structures:
</p>

<p>
  Vectors: <code class="expr">#(1 2 3 4)</code><br/>
  Hash tables: <code class="expr">(hasheq 'x 5 'y 6)</code><br/>
  Sets: <code class="expr">(set 1 2 3 4)</code><br/>
</p>

<p>
  Vectors and lists are sequential and ordered collections.
  Sets are not ordered, and they cannot contain duplicate elements.
  Hash tables are key-value collections, where both keys and values can be any values.
  Here, we've used what Racket calls a <em>symbol</em> (<code>'x</code>) for the keys.
</p>

<p>
  Now I'll tell you another thing that may surprise you: some Racket collections are <em>immutable</em> - they can never change.
  When you do anything on a list, including adding and removing elements, you actually get a brand new list.
  In general, Racket encourages you to have as little mutable state as possible.
  For example, instead of "for" loops and other state-changing constructs, most of the time you'll see functions doing transformations on immutable data and returning new collections, without changing the old one.
</p>

<p>
  A prime example of this is <code>map</code>. <code>map</code> is a <em>higher order function</em>, which means that it takes another function as an argument.
  For example, you can ask <code>map</code> to increment each number in a vector by passing it the <code>inc</code> function, followed by the vector.
  Try it for yourself: type <code class="expr">(map add1 '(1 2 3 4))</code> to continue.
</p>
